# A0139102U
###### \dailyplanner\commons\util\ArgumentFormatUtil.java
``` java
public class ArgumentFormatUtil {

	public static boolean isValidAddArgumentFormat(String trimmedArgs) {
		if (trimmedArgs.length() != 1 && trimmedArgs.charAt(1) == '/') {
			return false;
		}
		for (int k = 0; k < trimmedArgs.length(); k++) {
			if (trimmedArgs.charAt(k) == '/') {
				if (!(k + 1 == trimmedArgs.length())) {
					if (trimmedArgs.charAt(k + 1) == ' ') {
						return false;
					}
				} else {
					if (trimmedArgs.charAt(k) == '/')
						return false;
				}

			}
		}
		return true;
	}

	public static boolean isValidEditArgumentFormat(String args) {
		args = args.trim();
	    //If no index, return invalid
	    if(noIndexInArgs(args)) {
	        return false;
	    }
	    
	    //Return false if string is only a number
	    if (StringUtils.isNumeric(args)) {
	        return false;
	    }
	    
	    //Return false if no space before s/
	    if(args.contains("s/")) {
	        if (ifNoWhiteSpaceBeforeParameter(args, "s/")) {
	            return false;
	        }
	    }
	    
	  //Return false if no space before e/
	    if(args.contains("e/")) {
	        if (ifNoWhiteSpaceBeforeParameter(args, "e/")) {
                return false;
            }
        }
	  //Return false if no space before c/
	    if(args.contains("c/")) {
	        if (ifNoWhiteSpaceBeforeParameter(args, "c/")) {
                return false;
            }
        }    
	    return true;  
	}

    private static boolean ifNoWhiteSpaceBeforeParameter(String args, String parameter) {
        return args.charAt(args.indexOf(parameter)-1) != ' ';
    }

    private static boolean noIndexInArgs(String args) {
        return !Character.isDigit(args.charAt(0));
    }
}
```
###### \dailyplanner\history\HistoryManager.java
``` java
public class HistoryManager {

	private Stack<Instruction> recordCommand = new Stack<Instruction>();

	public Instruction getLastInstruction() {
		return recordCommand.pop();
	}

	public void stackAddInstruction(ReadOnlyTask toPush) {
		recordCommand.push(new Instruction("A", toPush));
	}
	
	public void stackDeleteInstruction(ReadOnlyTask toPush) {
		recordCommand.push(new Instruction("D", toPush));
	}
	
	public void stackEditInstruction(ReadOnlyTask originalTask, ReadOnlyTask editedTask) {
		recordCommand.push(new Instruction("EA", originalTask));
		recordCommand.push(new Instruction("ED", editedTask));
    }

	public void stackUnpinInstruction(ReadOnlyTask taskToUnpin) {
		recordCommand.push(new Instruction("UP", taskToUnpin));
	}

	public void stackPinInstruction(ReadOnlyTask taskToUnpin) {
		recordCommand.push(new Instruction("P", taskToUnpin));
	}
	
	public void stackUncompleteInstruction(ReadOnlyTask taskToUncomplete) {
        recordCommand.push(new Instruction("UC", taskToUncomplete));
    }

    public void stackCompleteInstruction(ReadOnlyTask taskToComplete) {
        recordCommand.push(new Instruction("C", taskToComplete)); 
    }
}
```
###### \dailyplanner\history\Instruction.java
``` java
public class Instruction {

	private String reverseCommand;
	private ReadOnlyTask task;

	public Instruction(String cmd, ReadOnlyTask task) {
		this.reverseCommand = cmd;
		this.task = task;
	}

	public String getReverse() {
		return reverseCommand;
	}

	public void setReverse(String cmd) {
		this.reverseCommand = cmd;
	}
	
	public ReadOnlyTask getTask() {
		return this.task;
	}
}
```
###### \dailyplanner\logic\commands\AddCommand.java
``` java
    public AddCommand(String taskName, DateTime start, DateTime end, Set<String> cats) throws IllegalValueException {
        final Set<Category> catSet = new HashSet<>();
        for (String catName : cats) {
            catSet.add(new Category(catName));
        }
        this.toAdd = new Task(taskName, start, end, false, false, new UniqueCategoryList(catSet));

    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            taskList = model.getDailyPlanner().getTaskList();
            model.getHistory().stackDeleteInstruction(toAdd);
            model.addTask(toAdd);
            model.updatePinBoard();

            if (isClash(toAdd))
                return new CommandResult(
                        String.format(MESSAGE_WARNING_CLASH, taskList.get(getIndexOfClashingTask(toAdd))));

            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }

    }

    private boolean isClash(Task toAdd) {
        return getIndexOfClashingTask(toAdd) > -1;
    }
```
###### \dailyplanner\logic\commands\AddCommand.java
``` java
    /**
     * Returns the index of the task clashing with argument, returns -1 if no
     * clash
     */
    public int getIndexOfClashingTask(Task toCheck) {

        if (!(DateUtil.hasStartandEndTime(toCheck))) {
            return -1;
        }
        Time toAddStartTiming = toCheck.getStart().getTime();
        Time toAddEndTiming = toCheck.getEnd().getTime();

        for (int i = 0; i < taskList.size(); i++) {
            ReadOnlyTask storedTask = taskList.get(i);
            if (DateUtil.hasStartandEndTime(storedTask)) {
                if (notSameTask(toCheck, storedTask)) {
                    if (isSameStartDate(toCheck, storedTask)) {
                        Time tasksEndTiming = storedTask.getEnd().getTime();
                        Time tasksStartTiming = storedTask.getStart().getTime();

                        if (isStartTimeClashing(toAddStartTiming, tasksEndTiming, tasksStartTiming)) {
                            return i;
                        }
                        if (isEndTimeClashing(toAddEndTiming, tasksEndTiming, tasksStartTiming)) {
                            return i;
                        }
                        if (timingSpansEntireTask(toAddStartTiming, toAddEndTiming, tasksEndTiming, tasksStartTiming)) {
                            return i;
                        }
                    }
                }

            }
        }
        return -1;
    }

    private boolean notSameTask(Task toCheck, ReadOnlyTask storedTask) {
        return !(toCheck == storedTask);
    }

    private boolean timingSpansEntireTask(Time toAddStartTiming, Time toAddEndTiming, Time tasksEndTiming,
            Time tasksStartTiming) {
        return ((toAddEndTiming.compareTo(tasksEndTiming) > 0) || (toAddEndTiming.compareTo(tasksEndTiming) == 0))
                && ((toAddStartTiming.compareTo(tasksStartTiming) < 0)
                        || (toAddStartTiming.compareTo(tasksStartTiming) == 0));
    }

    private boolean isEndTimeClashing(Time toAddEndTiming, Time tasksEndTiming, Time tasksStartTiming) {
        return (toAddEndTiming.compareTo(tasksStartTiming) > 0) && (toAddEndTiming.compareTo(tasksEndTiming) < 0);
    }

    private boolean isStartTimeClashing(Time toAddStartTiming, Time tasksEndTiming, Time tasksStartTiming) {
        return (toAddStartTiming.compareTo(tasksEndTiming) < 0) && (toAddStartTiming.compareTo(tasksStartTiming) > 0);
    }

    private boolean isSameStartDate(Task toCheck, ReadOnlyTask storedTask) {
        return toCheck.getStart().getDate().compareTo(storedTask.getStart().getDate()) == 0;
    }

}
```
###### \dailyplanner\logic\commands\ClearCommand.java
``` java
    @Override
    public CommandResult execute() {
        assert model != null;
        model.resetData(DailyPlanner.getEmptyDailyPlanner());
        model.resetPinBoard();
        model.setLastTaskAddedIndex(0);
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \dailyplanner\logic\commands\DeleteCommand.java
``` java
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);

        try {
        	model.getHistory().stackAddInstruction(taskToDelete);
            model.deleteTask(taskToDelete);
            model.updatePinBoard();
            
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
    }

}
```
###### \dailyplanner\logic\commands\DeleteCompletedCommand.java
``` java
	@Override
	public CommandResult execute() {

		final Set<String> keywordSet = new HashSet<>(Arrays.asList(new String[] { "complete" }));
		model.updateFilteredTaskListByCompletion(keywordSet);
		UnmodifiableObservableList<ReadOnlyTask> completedList = model.getFilteredTaskList();
		
		int size = completedList.size();
		for (int i = 0; i < size; i++) {
			ReadOnlyTask taskToDelete = completedList.get(0);

			try {
				model.getHistory().stackAddInstruction(taskToDelete);
				model.deleteTask(taskToDelete);
				model.updatePinBoard();

			} catch (TaskNotFoundException pnfe) {
				assert false : "The target task cannot be missing";
			}
		}
		
		model.updateFilteredListToShowAll();
		model.setLastShowDate(StringUtil.EMPTY_STRING);
		return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, "all completed"));
	}
}
```
###### \dailyplanner\logic\commands\EditCommand.java
``` java
	public final int targetIndex;
	private final Optional<String> taskName;
	private final Optional<DateTime> start;
	private final Optional<DateTime> end;
	private final Optional<Set<String>> categories;
	private Optional<UniqueCategoryList> categoriesSet;

	public EditCommand(int targetIndex, String taskName, DateTime start, DateTime end, Set<String> cats)
			throws IllegalValueException {
		this.targetIndex = targetIndex;
		this.taskName = Optional.ofNullable(taskName);
		this.start = Optional.ofNullable(start);
		this.end = Optional.ofNullable(end);
		this.categories = Optional.ofNullable(cats);
		this.categoriesSet = Optional.empty();

		if (cats.size() != 0) {
			final Set<Category> catSet = new HashSet<>();

			for (String catName : cats) {
				catSet.add(new Category(catName));
			}
			this.categoriesSet = Optional.of(new UniqueCategoryList(catSet));
		}
	}
```
###### \dailyplanner\logic\commands\FindCommand.java
``` java
    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### \dailyplanner\logic\commands\UndoCommand.java
``` java
	@Override
	public CommandResult execute() {
		Instruction undoInstruction = model.getHistory().getLastInstruction();
		ReadOnlyTask taskToUndo = null;
		
		taskToUndo = undoInstruction.getTask();

		if (undoInstruction.getReverse().equals("A")) {
			try {
				model.addTask((Task) taskToUndo);
			} catch (IllegalValueException e) {
				e.printStackTrace();
			}
		}

		if (undoInstruction.getReverse().equals("D")) {
			try {
				model.deleteTask(taskToUndo);
			} catch (TaskNotFoundException e) {
				e.printStackTrace();
			}
		}

		if (undoInstruction.getReverse().equals("ED")) {
			try {
				model.deleteTask(taskToUndo);

			} catch (TaskNotFoundException e) {
				e.printStackTrace();
			}

			// Get next instruction from stack to generate and add the old task
			// back
			// The instruction is guaranteed to be an "EA" instruction
			undoInstruction = model.getHistory().getLastInstruction();
			taskToUndo = null;

			taskToUndo = undoInstruction.getTask();

			try {
				model.addTask((Task) taskToUndo);
			} catch (DuplicateTaskException e) {
				e.printStackTrace();
			}
		}

		if (undoInstruction.getReverse().equals("UP")) {
			int indexInPinBoard = model.getPinnedTaskList().indexOf(taskToUndo);
			try {
				model.unpinTask(indexInPinBoard);
			} catch (TaskNotFoundException e) {
				e.printStackTrace();
			}
		}
		
		if (undoInstruction.getReverse().equals("P")) {
			try {
				model.pinTask(taskToUndo);
			} catch (TaskNotFoundException e) {
				e.printStackTrace();
			}
		}
		
		if (undoInstruction.getReverse().equals("UC")) {
            int indexInTaskList = model.getFilteredTaskList().indexOf(taskToUndo);
            model.uncompleteTask(indexInTaskList);
        }
		
		if (undoInstruction.getReverse().equals("C")) {
            try {
                model.markTaskAsComplete(taskToUndo);
            } catch (TaskNotFoundException e) {
                e.printStackTrace();
            }
        }
		
		model.updatePinBoard();

		return new CommandResult(String.format(MESSAGE_SUCCESS));

	}

}
```
###### \dailyplanner\logic\parser\Parser.java
``` java

	private Command prepareEdit(String arguments) {

		int index = 0;
		String taskName = null;
		String start = null, end = null;
		DateTime formattedStart = null, formattedEnd = null;
		Set<String> categories = new HashSet<String>();
		
		String trimmedArgs = arguments.trim();
		
		if(!(ArgumentFormatUtil.isValidEditArgumentFormat(arguments))){
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
		}

		HashMap<String, String> mapArgs = parseEdit(trimmedArgs);

		// If arguments are in hashmap, pass them to addCommand, if not pass
		// them as empty string
		// Change date to "dd/mm/yy/", time to "hh:mm"

		nattyParser natty = new nattyParser();

		if (mapArgs.containsKey("index")) {
			index = Integer.parseInt(mapArgs.get("index"));
		}
		if (mapArgs.containsKey("taskName")) {
			taskName = mapArgs.get("taskName");
		}
		if (mapArgs.containsKey("start")) {
			String startString = mapArgs.get("start");
			// if field is empty, delete start
			if (startString.equals("")) {
				formattedStart = new DateTime(new Date(""), new Time(""));
			}
			// if start time is given
			else if (startString.contains("am") || startString.contains("pm")) {
				start = natty.parse(startString);
				Date startDate = new Date(start.split(" ")[0]);
				Time startTime = new Time(start.split(" ")[1]);
				formattedStart = new DateTime(startDate, startTime);
			} else {
				start = natty.parseDate(startString);
				Date startDate = new Date(start);
				formattedStart = new DateTime(startDate, new Time(""));
			}
		}
		if (mapArgs.containsKey("end")) {
			String endString = mapArgs.get("end");
			// if field is empty, delete end
			if (endString.equals("")) {
				formattedEnd = new DateTime(new Date(""), new Time(""));
			}
			// if end time is given
			else if (endString.contains("am") || endString.contains("pm")) {
				// if end date is given
				if (endString.length() >= 7 && !Character.isDigit(endString.charAt(0))) {
					end = natty.parse(endString);
					Date endDate = new Date(end.split(" ")[0]);
					Time endTime = new Time(end.split(" ")[1]);
					formattedEnd = new DateTime(endDate, endTime);
				} else {
					Date endDate;
					if (!mapArgs.containsKey("start")) {
						endDate = new Date(natty.parseDate("today"));
					} else {
						endDate = new Date(start.split(" ")[0]);
					}
					Time endTime = new Time(natty.parseTime(endString));
					formattedEnd = new DateTime(endDate, endTime);
				}
			} else {
				end = natty.parseDate(endString);
				Date endDate = new Date(end);
				formattedEnd = new DateTime(endDate, new Time(""));
			}
		}
		if (mapArgs.containsKey("cats")) {
			// if field is empty, delete categories
			if (mapArgs.get("cats").equals("")) {
				categories = new HashSet<String>();
			} else {
				String[] catArray = mapArgs.get("cats").split(" ");
				categories = new HashSet<String>(Arrays.asList(catArray));
			}
		}

		try {
			return new EditCommand(index, taskName, formattedStart, formattedEnd, categories);
		} catch (IllegalValueException ive) {
			return new IncorrectCommand(ive.getMessage());
		}
	}

	/**
	 * Parses arguments in the context of the add task command.
	 *
	 * @param args
	 *            full command args string
	 * @return the prepared command
	 */

```
###### \dailyplanner\model\Model.java
``` java
	/** Clears existing backing model and replaces with the provided new data. */
    void resetData(ReadOnlyDailyPlanner newData);

    /** Returns the DailyPlanner */
    ReadOnlyDailyPlanner getDailyPlanner();
    
    HistoryManager getHistory();

    /** Deletes the given task. */
    void deleteTask(ReadOnlyTask target) throws UniqueTaskList.TaskNotFoundException;

    /** Adds the given task */
    void addTask(Task task) throws UniqueTaskList.DuplicateTaskException;

    /** Marks the given task as complete  */
    void markTaskAsComplete(ReadOnlyTask taskToComplete) throws TaskNotFoundException;
    
    /** Unmarks the given task as incomplete  */
    void markTaskAsIncomplete(ReadOnlyTask taskToIncomplete) throws TaskNotFoundException;
    
    /** Pins the given task. */
    void pinTask(ReadOnlyTask taskToPin) throws TaskNotFoundException;

    /** Unpins the given task. */
	void unpinTask(int i) throws TaskNotFoundException;
    
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();
    
    /** Returns the list of pinned task as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getPinnedTaskList();

    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredListToShowAll();

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskList(Set<String> keywords);
    
    /** Updates the filter of the filtered task list to filter by the given date*/
    void updateFilteredTaskListByDate(Set<String> keywords);

    /** Updates the filter of the filtered task list to show only completed tasks*/
	void updateFilteredTaskListByCompletion(Set<String> keywords);

    /** Returns the index of the last task that was added to the task list */
    public int getLastTaskAddedIndex();
    
    /** Sets the stored index of the last task added */
    public void setLastTaskAddedIndex(int index);
    
    /** Returns the last task added index as the property itself */
    public IntegerProperty getLastTaskAddedIndexProperty();
    
    /** Returns last shown date command */
    public String getLastShowDate();
    
    /** Sets last shown date given by show command, this date is dislayed in green beside 'Your Tasks' in GUI*/
    public void setLastShowDate(String showInput);
    
    /** Returns the StringProperty holding the last shown date command */
    public StringProperty getLastShowDateProperty();

    /** Resets the pinboard to an empty pinboard */
	public void resetPinBoard();
	
	/** Uncompletes task with given index in taskList */
    public void uncompleteTask(int indexInTaskList);
	
	/** Refreshes the pin board after a command is carried out */
	public void updatePinBoard();

}
```
###### \dailyplanner\ui\HelpWindow.java
``` java
    private void configure(){
           Scene scene = new Scene(mainPane);
           //Null passed as the parent stage to make it non-modal.
           dialogStage = createDialogStage(TITLE, null, scene);
           dialogStage.setMaximized(true); //TODO: set a more appropriate initial size
           setIcon(dialogStage, ICON);
           
           WebView browser = new WebView();                 
           browser.getEngine().loadContent("<h1>Help</h1><p style=\"color:blue;\"><b>add </b></br></p><p>add [TASKNAME] s/[START] e/[END] c/[CATEGORY]..</p><p><sub>Except <mark>TASKNAME</mark>, all the fields above are optional</sub></p><em>Examples: </em><p>add Math Assignment s/today </p><p>add Music Lesson s/12 nov 2pm e/5pm</p><p>add Sleepover s/today 9pm e/tomorrow 9am </p><p>add CS1020 Revision </p><p style=\"color:blue;\"><br><b>delete </b></br></p><p>delete [INDEX] or delete[COMPLETED]</p><em>Examples: </em><p>delete 1 </p><p>delete completed <em>(deletes all completed tasks)</em></p><p style=\"color:blue;\"><br><b>edit </b></br></p><p>edit [INDEX] [TASKNAME] s/[START] e/[END]</p><p><sub>Except <mark>INDEX</mark>, only one of the other fields has to be entered.</sub></p><em>Examples: </em><p>edit 1 Math Assignment</p><p>edit 5 Music Lesson s/6pm e/7pm</p><p>edit 9 Freshmen Camp s/18Dec 1pm e/17112016 9am </p><p>edit 11 CS1020 Revision s/tomorrow </p><p style=\"color:blue;\"><br><b>find </b></br></p><p>find [TASKNAME]</p><em>Examples: </em><p>find CS1020 </p><p style=\"color:blue;\"><br><b>complete </b></br></p><p>complete[INDEX]</p><em>Examples: </em><p>complete 5 </p><p style=\"color:blue;\"><br><b>show </b></br></p><p>show [DATE]/[COMPLETED]</p><em>Examples: </em><p>show complete </p><p>show <em>(shows all tasks)</em></p><p>show today </p><p>show not complete</p><p style=\"color:blue;\"><br><b>undo </b></br></p><p>undo</p><em>Examples: </em><p>undo</p><p style=\"color:blue;\"><br><b>pin </b></br></p><p>pin[INDEX]</p><em>Examples: </em><p>pin 5 <em>(pins a task to the pin board)</em></p>" );
           FxViewUtil.applyAnchorBoundaryParameters(browser, 0.0, 0.0, 0.0, 0.0);
           mainPane.getChildren().add(browser);
       }

    public void show() {
        dialogStage.showAndWait();
    }
}
```
