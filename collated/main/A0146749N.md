# A0146749N
###### \dailyplanner\commons\util\DateUtil.java
``` java
public class DateUtil {
    private static final String STRING_REPRESENTING_NOW = "now";
    
	public static boolean hasStartandEndTime(ReadOnlyTask storedTask) {
		Time storedStartTime = storedTask.getStart().getTime();
		Time storedEndTime = storedTask.getEnd().getTime();

		if (!(storedStartTime.toString().equals("")) && !(storedEndTime.toString().equals("")))
			return true;

		return false;
	}
	
	public static boolean withinDateRange(ReadOnlyTask task, String keyword) {
        int keyDate = SubStringOfStringAsInt(0,2,keyword);
        int keyMonth = SubStringOfStringAsInt(3,5,keyword);
        int keyYear = SubStringOfStringAsInt(6,keyword);
        Date taskStart = task.getStart().m_date;
        Date taskEnd = task.getEnd().m_date;
        if (startDateTimeAndEndDateTimeIsEmpty(taskStart, taskEnd)) {
            return false;
        } else if (dateTimeIsEmpty(taskStart)) {
            taskStart = taskEnd;
        } else if (dateTimeIsEmpty(taskEnd)) {
            taskEnd = taskStart;
        }
        return isKeyBetweenStartAndEnd(keyDate, keyMonth, keyYear, taskStart, taskEnd);
    }

    private static boolean isKeyBetweenStartAndEnd(int keyDate, int keyMonth, int keyYear, Date taskStart,
            Date taskEnd) {
        Calendar start = Calendar.getInstance();
        start.set(taskStart.m_year + 1900, taskStart.m_month, taskStart.m_day);
        Calendar searchKey = Calendar.getInstance();
        searchKey.set(keyYear + 1900, keyMonth, keyDate);
        Calendar end = Calendar.getInstance();
        end.set(taskEnd.m_year + 1900, taskEnd.m_month, taskEnd.m_day);
        return (start.compareTo(searchKey) <= 0 && end.compareTo(searchKey) >= 0);
    }

    private static boolean dateTimeIsEmpty(Date taskStart) {
        return taskStart.m_value.equals("");
    }

    private static boolean startDateTimeAndEndDateTimeIsEmpty(Date taskStart, Date taskEnd) {
        return dateTimeIsEmpty(taskStart) && dateTimeIsEmpty(taskEnd);
    }
	
	private static int SubStringOfStringAsInt(int start, int end, String keyword) {
	    return Integer.parseInt(keyword.substring(start, end));
	}
	
	private static int SubStringOfStringAsInt(int start, String keyword) {
        return Integer.parseInt(keyword.substring(start));
    }
    
	/** Returns current time as DateTime object */
     public static DateTime nowAsDateTime() {
            nattyParser natty = new nattyParser();
            String dateTimeAsString = natty.parse(STRING_REPRESENTING_NOW);
            return getDateTimeFromString(dateTimeAsString);
        }

    private static DateTime getDateTimeFromString(String dateTimeAsString) {
        String[] dateTimeArray = dateTimeAsString.split(" ");
        Date nowDate = new Date(dateTimeArray[0]);
        Time nowTime = new Time(dateTimeArray[1]);
        return new DateTime(nowDate,nowTime);
    }
     
    public static int convertTo24HrFormat(Time firstTime) {
		if (firstTime.m_meridiem.equals("AM") && firstTime.m_hour == 12) {
			return 0;
		} else if (firstTime.m_meridiem.equals("PM") && firstTime.m_hour != 12) {
			return firstTime.m_hour + 12;
		} else {
			return firstTime.m_hour;
		}
	}
    
    /** Checks if string is in dd/mm/yyyy format 
     * @return */
    public static boolean isValidDayMonthAnd4DigitYearFormat(String date) {
        if (date.matches("([0-9]{2})/([0-9]{2})/([0-9]{4})") || date.matches("([0-9]{1})/([0-9]{2})/([0-9]{4})"))
            return true;
        else
           return false;
    }
    
    /** Checks if string is in dd/mm/yy format 
     * @return */
    public static boolean isValidDayMonthAnd2DigitYearFormat(String date) {
        if (date.matches("([0-9]{2})/([0-9]{2})/([0-9]{2})") || date.matches("([0-9]{1})/([0-9]{2})/([0-9]{2})"))
            return true;
        else
           return false;
    }
    
    /** Converts string from dd/mm/yy to dd/mm/20yy format  */
    public static String convertTo4DigitYearFormat(String date) {
        String dayAndMonth = date.substring(0,6);
        String yy = date.substring(6);
        return dayAndMonth + "20" + yy;
    }

}
```
###### \dailyplanner\logic\commands\CompleteCommand.java
``` java
    @Override
    public CommandResult execute() {

	UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToComplete = lastShownList.get(targetIndex - 1);

        try {
            model.getHistory().stackUncompleteInstruction(taskToComplete);
            model.markTaskAsComplete(taskToComplete);
            model.updatePinBoard();
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_COMPLETED_TASK_SUCCESS, taskToComplete));
    }

}
```
###### \dailyplanner\logic\commands\EditCommand.java
``` java
	@Override
	public CommandResult execute() {

		UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

		if (lastShownList.size() < targetIndex) {
			indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
		}

		ReadOnlyTask taskToEdit = lastShownList.get(targetIndex - 1);

		String toAddName = taskToEdit.getName();
		if (taskName.isPresent()) {
			toAddName = taskName.get();
		}
		DateTime toAddStart = taskToEdit.getStart();
		if (start.isPresent()) {
			toAddStart = start.get();
		}
		DateTime toAddEnd = taskToEdit.getEnd();
		if (end.isPresent()) {
			toAddEnd = end.get();
		}
		UniqueCategoryList toAddCats = taskToEdit.getCats();
		if (categoriesSet.isPresent()) {
			toAddCats = categoriesSet.get();
		}

		Task toAdd = new Task(toAddName, toAddStart, toAddEnd, taskToEdit.isComplete(), taskToEdit.isPinned(),
				toAddCats);

		try {
			model.getHistory().stackEditInstruction(taskToEdit, toAdd);
			model.deleteTask(taskToEdit);
			model.addTask(toAdd);
			model.updatePinBoard();
		} catch (TaskNotFoundException pnfe) {
			assert false : "The target task cannot be missing";
		} catch (UniqueTaskList.DuplicateTaskException e) {
			return new CommandResult(MESSAGE_DUPLICATE_TASK);
		}
		return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
	}
}
```
###### \dailyplanner\logic\commands\PinCommand.java
``` java
	public PinCommand(int targetIndex) {
		this.targetIndex = targetIndex;
	}

	@Override
	public CommandResult execute() {

		UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

		if (lastShownList.size() < targetIndex) {
			indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
		}
		
		ReadOnlyTask taskToPin = lastShownList.get(targetIndex - 1);

		if (model.getPinnedTaskList().contains(taskToPin)) {
			indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(MESSAGE_DUPLICATE_PINNED_TASK);
		}
		
		try {
			model.getHistory().stackUnpinInstruction(taskToPin);
			model.pinTask(taskToPin);
			model.updatePinBoard();
		} catch (TaskNotFoundException pnfe) {
			assert false : "The target task cannot be missing";
		}
		return new CommandResult(String.format(MESSAGE_PINNED_TASK_SUCCESS, taskToPin));
	}

}
```
###### \dailyplanner\logic\commands\SelectCommand.java
``` java
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex - 1));
        return new CommandResult(String.format(MESSAGE_SELECT_TASK_SUCCESS, targetIndex));

    }

}
```
###### \dailyplanner\logic\commands\ShowCommand.java
``` java
public class ShowCommand extends Command {

	public static final String COMMAND_WORD = "show";

	public static final String MESSAGE_SUCCESS = "Showing %1$s tasks";

	private final Set<String> keywords;

	public ShowCommand() {
		keywords = null;
	}
```
###### \dailyplanner\logic\commands\ShowCommand.java
``` java
	public ShowCommand(Set<String> keywords) {
		this.keywords = keywords;
	}

	@Override
	public CommandResult execute() {
		if (keywords == null) {
			model.updateFilteredListToShowAll();
			model.setLastShowDate(StringUtil.EMPTY_STRING);
			return new CommandResult(String.format(MESSAGE_SUCCESS, "all"));
		} else {
			if (keywords.contains("complete")) {
				model.updateFilteredTaskListByCompletion(keywords);
				model.setLastShowDate("completed");
			} else if(keywords.contains("not complete")) {
			    model.updateFilteredTaskListByCompletion(keywords);
			    model.setLastShowDate("not completed");
			} else {
				model.updateFilteredTaskListByDate(keywords);
				model.setLastShowDate((String) keywords.toArray()[0]);
			}
			return new CommandResult(String.format(MESSAGE_SUCCESS, model.getFilteredTaskList().size()));
		}
	}
}
```
###### \dailyplanner\logic\commands\UncompleteCommand.java
``` java
    @Override
    public CommandResult execute() {

	UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        ReadOnlyTask taskToUncomplete = lastShownList.get(targetIndex - 1);

        try {
            model.getHistory().stackCompleteInstruction(taskToUncomplete);
            model.markTaskAsIncomplete(taskToUncomplete);
            model.updatePinBoard();
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_COMPLETED_TASK_SUCCESS, taskToUncomplete));
    }

}
```
###### \dailyplanner\logic\commands\UnpinCommand.java
``` java
    @Override
    public CommandResult execute() {

	UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getPinnedTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        ReadOnlyTask taskToUnpin = lastShownList.get(targetIndex - 1);

        try {
        	model.getHistory().stackPinInstruction(taskToUnpin);
            model.unpinTask(targetIndex-1);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_COMPLETED_TASK_SUCCESS, taskToUnpin));
    }

}
```
###### \dailyplanner\logic\LogicManager.java
``` java
	@Override
	public ObservableList<ReadOnlyTask> getPinnedTaskList() {
		return model.getPinnedTaskList();
	}

	@Override
	public IntegerProperty getLastTaskAddedIndexProperty() {
		return model.getLastTaskAddedIndexProperty();
	}

	@Override
	public StringProperty getLastShowDateProperty() {
		return model.getLastShowDateProperty();
	}

}
```
###### \dailyplanner\logic\parser\Parser.java
``` java
    private Command prepareUnpin(String arguments) {
		String trimmedArg = arguments.trim();
		Optional<Integer> index = parseIndex(trimmedArg);
		if (!index.isPresent()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
		}
		return new UnpinCommand(index.get());
	}

	private Command preparePin(String arguments) {
		String trimmedArg = arguments.trim();
		Optional<Integer> index = parseIndex(trimmedArg);
		if (!index.isPresent()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, PinCommand.MESSAGE_USAGE));
		}
		return new PinCommand(index.get());
	}

	private Command prepareComplete(String arguments) {
		String trimmedArg = arguments.trim();
		Optional<Integer> index = parseIndex(trimmedArg);
		if (!index.isPresent()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
		}
		return new CompleteCommand(index.get());
	}
	
	private Command prepareUncomplete(String arguments) {
	    String trimmedArg = arguments.trim();
        Optional<Integer> index = parseIndex(trimmedArg);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UncompleteCommand.MESSAGE_USAGE));
        }
        return new UncompleteCommand(index.get());
    }

```
###### \dailyplanner\logic\parser\Parser.java
``` java
	private boolean hasTaskName(String arguments) {
		String trimmedArgs = arguments.trim();
		if (trimmedArgs.length() == 1) {
			return true;
		} else if (trimmedArgs.length() >= 2 && trimmedArgs.charAt(1) == '/') {
			return false;
		} else {
			return true;
		}
	}

	private String getTaskNameFromArguments(String arguments) {
		if (arguments.contains("/")) {
			String[] firstPart = arguments.split("/");
			return firstPart[0].substring(0, firstPart[0].length() - 2);
		} else {
			return arguments;
		}
	}

	/**
	 * Extracts the new task's categories from the add command's category arguments
	 * string. Merges duplicate category strings.
	 */
	private static Set<String> getCategoriesFromArgs(String catArguments) throws IllegalValueException {
		// no cats
		if (catArguments.isEmpty()) {
			return Collections.emptySet();
		}
		// replace first delimiter prefix, then split
		final Collection<String> catStrings = Arrays.asList(catArguments.replaceFirst(" t/", "").split(" t/"));
		return new HashSet<>(catStrings);
	}

	/**
	 * Parses arguments in the context of the delete task command.
	 *
	 * @param args
	 *            full command args string
	 * @return the prepared command
	 */
	private Command prepareDelete(String args) {
		String trimmedArgs = args.trim();
		
		if (trimmedArgs.contains("complete")) {
			return new DeleteCompletedCommand();
		} else {

			Optional<Integer> index = parseIndex(trimmedArgs);
			if (!index.isPresent()) {
				return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
			}

			return new DeleteCommand(index.get());
		}
	}

	private Command prepareShow(String args) {
		final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
		if (!matcher.matches()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
		}

		// keywords delimited by whitespace
		final String keyword = matcher.group("keywords");

		String[] keywords = new String[1];

		if (keyword.contains("complete")) {
			if (keyword.contains("not")) {
				keywords[0] = "not complete";
			} else {
				keywords[0] = "complete";
			}
		} else {
			nattyParser natty = new nattyParser();
			keywords[0] = natty.parseDate(keyword);
		}
		final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
		return new ShowCommand(keywordSet);
	}

	/**
	 * Parses arguments in the context of the select task command.
	 *
	 * @param args
	 *            full command args string
	 * @return the prepared command
	 */
	private Command prepareSelect(String args) {
		String trimmedArg = args.trim();
		Optional<Integer> index = parseIndex(trimmedArg);
		if (!index.isPresent()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
		}

		return new SelectCommand(index.get());
	}

	/**
	 * Returns the specified index in the {@code command} IF a positive unsigned
	 * integer is given as the index. Returns an {@code Optional.empty()}
	 * otherwise.
	 */
	private Optional<Integer> parseIndex(String command) {
		final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
		if (!matcher.matches()) {
			return Optional.empty();
		}

		String index = matcher.group("targetIndex");
		if (!StringUtil.isUnsignedInteger(index)) {
			return Optional.empty();
		}
		return Optional.of(Integer.parseInt(index));

	}

	/**
	 * Parses arguments in the context of the find task command.
	 *
	 * @param args
	 *            full command args string
	 * @return the prepared command
	 */
	private Command prepareFind(String args) {
		/*if(!(ArgumentFormatUtil.isValidFindFormat(args))){
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
		}
		*/
		String trimmedArg = args.trim();
		final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(trimmedArg);
		if (!matcher.matches()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
		}

		// keywords delimited by whitespace
		final String[] keywords = matcher.group("keywords").split("\\s+");
		final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
		return new FindCommand(keywordSet);
	}

}
```
###### \dailyplanner\model\task\DateTime.java
``` java
	public final Date m_date;
	public final Time m_time;

	public DateTime(Date date, Time time) {
		m_date = date;
		m_time = time;
	}

	@Override
	public String toString() {
		if (m_date.toString().equals(""))
			return "";
		else if (m_time.toString().equals(""))
			return m_date.toString();
		else
			return m_date.toString() + " " + m_time.toString();
	}

	public Date getDate() {
		return m_date;
	}

	public Time getTime() {
		return m_time;
	}

	@Override
	public boolean equals(Object other) {
		return other == this // short circuit if same object
				|| (other instanceof DateTime // instanceof handles nulls
						&& m_date.equals(((DateTime) other).m_date) && m_time.equals(((DateTime) other).m_time)); // state
		// check
	}

	@Override
	public int hashCode() {
		return m_date.hashCode();
	}

	@Override
	public int compareTo(DateTime o) {
		if (!m_date.equals(o.m_date)) {
			return m_date.compareTo(o.m_date);
		} else {
			return m_time.compareTo(o.m_time);
		}

	}
}
```
###### \dailyplanner\model\task\Time.java
``` java
	public Time(String value) {
		assert value != null;
		m_value = value;
		if (!value.equals("")) {
			m_hour = Integer.parseInt(value.substring(0, 2));
			m_minute = Integer.parseInt(value.substring(3, 5));
			m_meridiem = value.substring(5);
		} else {
			m_hour = 20;
			m_minute = 0;
			m_meridiem = "PM";
		}
	}

	@Override
	public String toString() {
		return m_value;
	}

	@Override
	public boolean equals(Object other) {
		return other == this // short circuit if same object
				|| (other instanceof Time // instanceof handles nulls
						&& m_value.equals(((Time) other).m_value)); // state
		// check
	}

	@Override
	public int hashCode() {
		return m_value.hashCode();
	}

	@Override
	public int compareTo(Time o) {

		if (!m_meridiem.equals(o.m_meridiem)) {
			if (m_meridiem.equals("AM") && o.m_meridiem.equals("PM")) {
				return -1;
			} else {
				return 1;
			}
		}
		if (m_hour != o.m_hour) {
			if (m_hour == 12) {
				return -1;
			} else if (o.m_hour == 12) {
				return 1;
			}
			return m_hour - o.m_hour;
		}
		if (m_minute != o.m_minute) {
			return m_minute - o.m_minute;
		}

		return 0;
	}
}
```
