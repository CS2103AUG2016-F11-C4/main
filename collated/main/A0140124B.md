# A0140124B
###### \dailyplanner\logic\commands\AddCommand.java
``` java
    public AddCommand(String taskName, DateTime start, DateTime end, Set<String> tags) throws IllegalValueException {
        final Set<Category> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Category(tagName));
        }
        this.toAdd = new Task(taskName, start, end, false, false, new UniqueCategoryList(tagSet));

    }
  
    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            taskList = model.getAddressBook().getPersonList();
            model.getHistory().stackDeleteInstruction(toAdd);
            model.addPerson(toAdd);
            model.updatePinBoard();

            if (isClash(toAdd))
                return new CommandResult(
                        String.format(MESSAGE_WARNING_CLASH, taskList.get(getIndexOfClashingTask(toAdd))));

            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicatePersonException e) {
            return new CommandResult(MESSAGE_DUPLICATE_PERSON);
        }

    }

    private boolean isClash(Task toAdd) {
        return getIndexOfClashingTask(toAdd) > -1;
    }

    /**
     * Returns the index of the task clashing with argument, returns -1 if no
     * clash
     */
```
###### \dailyplanner\logic\commands\DeleteCommand.java
``` java
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredPersonList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);

        try {
            model.getHistory().stackAddInstruction(taskToDelete);
            model.deletePerson(taskToDelete);
            model.updatePinBoard();

        } catch (PersonNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(String.format(MESSAGE_DELETE_PERSON_SUCCESS, taskToDelete));
    }

}
```
###### \dailyplanner\logic\commands\DeleteCompletedCommand.java
``` java
    @Override
    public CommandResult execute() {

        final Set<String> keywordSet = new HashSet<>(Arrays.asList(new String[] { "complete" }));
        model.updateFilteredPersonListByCompletion(keywordSet);
        UnmodifiableObservableList<ReadOnlyTask> completedList = model.getFilteredPersonList();

        int size = completedList.size();
        for (int i = 0; i < size; i++) {
            ReadOnlyTask taskToDelete = completedList.get(0);

            try {
                model.getHistory().stackAddInstruction(taskToDelete);
                model.deletePerson(taskToDelete);
                model.updatePinBoard();

            } catch (PersonNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            }
        }

        model.updateFilteredListToShowAll();
        model.setLastShowDate(StringUtil.EMPTY_STRING);
        return new CommandResult(String.format(MESSAGE_DELETE_PERSON_SUCCESS, "all completed"));
    }

}
```
###### \dailyplanner\logic\commands\UndoCommand.java
``` java
		if (undoInstruction.getReverse().equals("UP")) {
			int indexInPinBoard = model.getPinnedTaskList().indexOf(taskToUndo);
			try {
				model.unpinTask(indexInPinBoard);
			} catch (PersonNotFoundException e) {
				e.printStackTrace();
			}
		}
		
		if (undoInstruction.getReverse().equals("P")) {
			try {
				model.pinTask(taskToUndo);
			} catch (PersonNotFoundException e) {
				e.printStackTrace();
			}
		}
		
		if (undoInstruction.getReverse().equals("UC")) {
            int indexInTaskList = model.getFilteredPersonList().indexOf(taskToUndo);
            model.uncompleteTask(indexInTaskList);
        }
		
		if (undoInstruction.getReverse().equals("C")) {
            try {
                model.markTaskAsComplete(taskToUndo);
            } catch (PersonNotFoundException e) {
                e.printStackTrace();
            }
        }
		
		model.updatePinBoard();

		return new CommandResult(String.format(MESSAGE_SUCCESS));

	}

}
```
###### \dailyplanner\logic\parser\Parser.java
``` java
	private Command prepareAdd(String args) {
		String taskName = "";
		String start = "", end = "";
		DateTime formattedStart = new DateTime(new Date(""), new Time(""));
		DateTime formattedEnd = new DateTime(new Date(""), new Time(""));
		Set<String> tags = new HashSet<String>();

		String trimmedArgs = args.trim();

		if (!(ArgumentFormatUtil.isValidAddArgumentFormat(trimmedArgs))) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}

		HashMap<String, String> mapArgs = parseAdd(trimmedArgs);

		// If arguments are in hashmap, pass them to addCommand, if not pass
		// them as empty string

		// Change date to "dd/mm/yy/", time to "hh:mm"
		nattyParser natty = new nattyParser();

		if (mapArgs.containsKey("taskName")) {
			taskName = mapArgs.get("taskName");
		}
		if (mapArgs.containsKey("start")) {
			String startString = mapArgs.get("start");
			// if start time is given
			if (startString.contains("am") || startString.contains("pm")) {
				start = natty.parse(startString);
				Date startDate = new Date(start.split(" ")[0]);
				Time startTime = new Time(start.split(" ")[1]);
				formattedStart = new DateTime(startDate, startTime);
			} else {
				start = natty.parseDate(startString);
				Date startDate = new Date(start);
				formattedStart = new DateTime(startDate, new Time(""));
			}
		}
		if (mapArgs.containsKey("end")) {
			String endString = mapArgs.get("end");
			// if end time is given
			if (endString.contains("am") || endString.contains("pm")) {
				// if end date is given
				if (endString.length() >= 7 && !Character.isDigit(endString.charAt(0))) {
					end = natty.parse(endString);
					Date endDate = new Date(end.split(" ")[0]);
					Time endTime = new Time(end.split(" ")[1]);
					formattedEnd = new DateTime(endDate, endTime);
				} else {
					Date endDate;
					if (!mapArgs.containsKey("start")) {
						endDate = new Date(natty.parseDate("today"));
					} else {
						endDate = new Date(start.split(" ")[0]);
					}
					Time endTime = new Time(natty.parseTime(endString));
					formattedEnd = new DateTime(endDate, endTime);
				}
			} else {
				end = natty.parseDate(endString);
				Date endDate = new Date(end);
				formattedEnd = new DateTime(endDate, new Time(""));
			}
		}
		if (mapArgs.containsKey("tags")) {
			String[] tagArray = mapArgs.get("tags").split(" ");
			tags = new HashSet<String>(Arrays.asList(tagArray));
		}
		try {
			return new AddCommand(taskName, formattedStart, formattedEnd, tags);
		} catch (IllegalValueException ive) {
			return new IncorrectCommand(ive.getMessage());
		}

	}

	

	/**
	 * Parses the arguments given by the user in the add command and returns it
	 * to prepareAdd in a HashMap with keys taskName, date, startTime, endTime,
	 * isRecurring
	 */

	private HashMap<String, String> parseAdd(String arguments) {
		HashMap<String, String> mapArgs = new HashMap<String, String>();
		String taskName = getTaskNameFromArguments(arguments);
		mapArgs.put("taskName", taskName);
		if (arguments.contains("/")) {
			String[] splitArgs = arguments.substring(taskName.length() + 1).split(" ");
			// loop through rest of arguments, add them to hashmap if valid

			argumentArrayToHashMap(mapArgs, splitArgs);
		}

		return mapArgs;
	}

	private HashMap<String, String> parseEdit(String arguments) {

		HashMap<String, String> mapArgs = new HashMap<String, String>();

		// Extract index
		String[] splitArgs1 = arguments.split(" ", 2);
		int indexStringLength = splitArgs1[0].length();
		String index = arguments.substring(0, indexStringLength);
		mapArgs.put("index", index);

		arguments = arguments.substring(indexStringLength + 1);
		if (hasTaskName(arguments)) {
			String taskName = getTaskNameFromArguments(arguments);
			mapArgs.put("taskName", taskName);
			if (arguments.contains("/")) {
				String[] splitArgs = arguments.substring(taskName.length() + 1).split(" ");
				argumentArrayToHashMap(mapArgs, splitArgs);
			}
		} else if (arguments.contains("/")) {
			String[] splitArgs = arguments.split(" ");
			argumentArrayToHashMap(mapArgs, splitArgs);
		}

		return mapArgs;
	}

	/*
	 * Loops through arguments, adds them to hashmap if valid
	 */

	private void argumentArrayToHashMap(HashMap<String, String> mapArgs, String[] splitArgs) {
		for (int i = 0; i < splitArgs.length; i++) {
			if (splitArgs[i].substring(0, 2).equals("s/")) {
				int j = i + 1;
				String arg = splitArgs[i].substring(2);
				while (j < splitArgs.length && !splitArgs[j].contains("/")) {
					arg += " " + splitArgs[j];
					j++;
				}
				mapArgs.put("start", arg);
			}

			if (splitArgs[i].substring(0, 2).equals("e/")) {
				int j = i + 1;
				String arg = splitArgs[i].substring(2);
				while (j < splitArgs.length && !splitArgs[j].contains("/")) {
					arg += " " + splitArgs[j];
					j++;
				}
				mapArgs.put("end", arg);
			}

			if (splitArgs[i].substring(0, 2).equals("c/")) {
				int j = i + 1;
				String arg = splitArgs[i].substring(2);
				while (j < splitArgs.length) {
					arg += " " + splitArgs[j].substring(2);
					j++;
				}
				i = j;
				mapArgs.put("tags", arg);

			}
		}
	}

```
###### \dailyplanner\model\Model.java
``` java

	/** Clears existing backing model and replaces with the provided new data. */
    void resetData(ReadOnlyDailyPlanner newData);

    /** Returns the AddressBook */
    ReadOnlyDailyPlanner getAddressBook();
    
    HistoryManager getHistory();

    /** Deletes the given person. */
    void deletePerson(ReadOnlyTask target) throws UniqueTaskList.PersonNotFoundException;

    /** Adds the given person */
    void addPerson(Task person) throws UniqueTaskList.DuplicatePersonException;

    /** Marks the given task as complete  */
    void markTaskAsComplete(ReadOnlyTask taskToComplete) throws PersonNotFoundException;
    
    /** Unmarks the given task as incomplete  */
    void markTaskAsIncomplete(ReadOnlyTask taskToIncomplete) throws PersonNotFoundException;
    
    /** Pins the given task. */
    void pinTask(ReadOnlyTask taskToPin) throws PersonNotFoundException;

    /** Unpins the given task. */
	void unpinTask(int i) throws PersonNotFoundException;
    
    /** Returns the filtered person list as an {@code UnmodifiableObservableList<ReadOnlyPerson>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredPersonList();
    
    /** Returns the list of pinned task as an {@code UnmodifiableObservableList<ReadOnlyPerson>} */
    UnmodifiableObservableList<ReadOnlyTask> getPinnedTaskList();

    /** Updates the filter of the filtered person list to show all persons */
    void updateFilteredListToShowAll();

    /** Updates the filter of the filtered person list to filter by the given keywords*/
    void updateFilteredPersonList(Set<String> keywords);
    
    /** Updates the filter of the filtered person list to filter by the given date*/
    void updateFilteredPersonListByDate(Set<String> keywords);

    /** Updates the filter of the filtered person list to show only completed tasks*/
	void updateFilteredPersonListByCompletion(Set<String> keywords);

    /** Returns the index of the last task that was added to the task list */
    public int getLastTaskAddedIndex();
    
    /** Sets the stored index of the last task added */
    public void setLastTaskAddedIndex(int index);
    
    /** Returns the last task added index as the property itself */
    public IntegerProperty getLastTaskAddedIndexProperty();
    
    /** Returns last shown date command */
    public String getLastShowDate();
    
    /** Sets last shown date given by show command, this date is dislayed in green beside 'Your Tasks' in GUI*/
    public void setLastShowDate(String showInput);
    
    /** Returns the StringProperty holding the last shown date command */
    public StringProperty getLastShowDateProperty();

    /** Resets the pinboard to an empty pinboard */
	public void resetPinBoard();
	
	/** Uncompletes task with given index in taskList */
    public void uncompleteTask(int indexInTaskList);
	
	/** Refreshes the pin board after a command is carried out */
	public void updatePinBoard();

}
```
###### \dailyplanner\model\task\Date.java
``` java
    /** Guarantees that value is in the format: DD/MM/YYYY */
    public Date(String value) {
        assert value != null;
        m_value = value;
        if (!value.equals("")) {
            m_day = Integer.parseInt(value.substring(0, 2));
            m_month = Integer.parseInt(value.substring(3, 5));
            m_year = Integer.parseInt(value.substring(6));
        } else {
            m_day = 0;
            m_month = 0;
            m_year = 3000;
        }
    }

    @Override
    public String toString() {
        return m_value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Date // instanceof handles nulls
                        && m_value.equals(((Date) other).m_value)); // state
        // check
    }

    @Override
    public int hashCode() {
        return m_value.hashCode();
    }

    @Override
    public int compareTo(Date o) {

        if (m_year != o.m_year) {
            return m_year - o.m_year;
        }
        if (m_month != o.m_month) {
            return m_month - o.m_month;
        }
        if (m_day != o.m_day) {
            return m_day - o.m_day;
        }

        return 0;
    }
}
```
###### \dailyplanner\ui\PinnedTaskPanel.java
``` java
public class PinnedTaskPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(PinnedTaskPanel.class);
    private static final String FXML = "PinnedTaskPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private ListView<ReadOnlyTask> pinListView;

    public PinnedTaskPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static PinnedTaskPanel load(Stage primaryStage, AnchorPane PinnedTaskPlaceholder,
                                       ObservableList<ReadOnlyTask> pinnedTaskList) {
        PinnedTaskPanel pinnedTaskPanel =
                UiPartLoader.loadUiPart(primaryStage, PinnedTaskPlaceholder, new PinnedTaskPanel());
        pinnedTaskPanel.configure(pinnedTaskList);
        return pinnedTaskPanel;
    }

    private void configure(ObservableList<ReadOnlyTask> personList) {
        setConnections(personList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<ReadOnlyTask> personList) {
        pinListView.setItems(personList);
        pinListView.setCellFactory(listView -> new PersonListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void setEventHandlerForSelectionChangeEvent() {
        pinListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in person list panel changed to : '" + newValue + "'");
                raise(new TaskPanelSelectionChangedEvent(newValue));
            }
        });
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            pinListView.scrollTo(index);
            pinListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class PersonListViewCell extends ListCell<ReadOnlyTask> {

        public PersonListViewCell() {
        }

        @Override
        protected void updateItem(ReadOnlyTask person, boolean empty) {
            super.updateItem(person, empty);

            if (empty || person == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(TaskCard.load(person, getIndex() + 1).getLayout());
            }
        }
    }

}
```
###### \dailyplanner\ui\ResultDisplay.java
``` java
    public void configure() {
        resultDisplayArea = new TextArea();
        resultDisplayArea.setEditable(false);
        resultDisplayArea.setId(RESULT_DISPLAY_ID);
        resultDisplayArea.getStyleClass().removeAll();
        resultDisplayArea.getStyleClass().add(STATUS_BAR_STYLE_SHEET);
        resultDisplayArea.setWrapText(true);
        resultDisplayArea.setText("");
        resultDisplayArea.textProperty().bind(displayed);
        displayed.setValue(INITIAL_RESULT_MESSAGE);
        FxViewUtil.applyAnchorBoundaryParameters(resultDisplayArea, 0.0, 0.0, 0.0, 0.0);
        mainPane.getChildren().add(resultDisplayArea);
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public void postMessage(String message) {
        displayed.setValue(message);
    }

}
```
