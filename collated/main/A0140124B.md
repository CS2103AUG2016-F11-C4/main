# A0140124B
###### \dailyplanner\logic\parser\nattyParser.java
``` java
	private com.joestelmach.natty.Parser nattyParserPackage;

	public nattyParser() {
		nattyParserPackage = new com.joestelmach.natty.Parser();
	}

	public String parse(String dateAndTime) {
		List<DateGroup> groups = nattyParserPackage.parse(dateAndTime);
		Date parsedDateAndTime = new Date();
		for (DateGroup group : groups) {
			parsedDateAndTime = group.getDates().get(0);
			break;

		}
		DateFormat df = new SimpleDateFormat("dd/MM/yyyy hh.mma");
		return df.format(parsedDateAndTime);
	}

	public String parseDate(String date) {
	   
	    if (DateUtil.isValidDayMonthAnd4DigitYearFormat(date)) {
            if (date.charAt(2) != '/') {
                return "0"+date;
            } else {
                return date;
            }
       }
	    
	    if (DateUtil.isValidDayMonthAnd2DigitYearFormat(date)) {
	        String dateWithAddedZero;
            if (date.charAt(2) != '/') {
                dateWithAddedZero =  "0"+date;
            } else {
                dateWithAddedZero = date;
            }
            dateWithAddedZero = DateUtil.convertTo4DigitYearFormat(dateWithAddedZero);
            
            return dateWithAddedZero;
       }
	    
		List<DateGroup> groups = nattyParserPackage.parse(date);
		Date parsedDate = new Date();
		for (DateGroup group : groups) {
			parsedDate = group.getDates().get(0);
			break;
		}
		DateFormat df = new SimpleDateFormat("dd/MM/yyyy");
		return df.format(parsedDate);
	}

	public String parseTime(String time) {
		List<DateGroup> groups = nattyParserPackage.parse(time);
		Date parsedTime = new Date();
		for (DateGroup group : groups) {
			parsedTime = group.getDates().get(0);
			break;

		}
		DateFormat df = new SimpleDateFormat("hh.mma");
		return df.format(parsedTime);
	}

}
```
###### \dailyplanner\logic\parser\Parser.java
``` java
	private Command prepareAdd(String args) {
		String taskName = "";
		String start = "", end = "";
		DateTime formattedStart = new DateTime(new Date(""), new Time(""));
		DateTime formattedEnd = new DateTime(new Date(""), new Time(""));
		Set<String> cats = new HashSet<String>();

		String trimmedArgs = args.trim();

		if (!(ArgumentFormatUtil.isValidAddArgumentFormat(trimmedArgs))) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}

		HashMap<String, String> mapArgs = parseAdd(trimmedArgs);

		// If arguments are in hashmap, pass them to addCommand, if not pass
		// them as empty string

		// Change date to "dd/mm/yy/", time to "hh:mm"
		nattyParser natty = new nattyParser();

		if (mapArgs.containsKey("taskName")) {
			taskName = mapArgs.get("taskName");
		}
		if (mapArgs.containsKey("start")) {
			String startString = mapArgs.get("start");
			// if start time is given
			if (startString.contains("am") || startString.contains("pm")) {
				start = natty.parse(startString);
				Date startDate = new Date(start.split(" ")[0]);
				Time startTime = new Time(start.split(" ")[1]);
				formattedStart = new DateTime(startDate, startTime);
			} else {
				start = natty.parseDate(startString);
				Date startDate = new Date(start);
				formattedStart = new DateTime(startDate, new Time(""));
			}
		}
		if (mapArgs.containsKey("end")) {
			String endString = mapArgs.get("end");
			// if end time is given
			if (endString.contains("am") || endString.contains("pm")) {
				// if end date is given
				if (endString.length() >= 7 && !Character.isDigit(endString.charAt(0))) {
					end = natty.parse(endString);
					Date endDate = new Date(end.split(" ")[0]);
					Time endTime = new Time(end.split(" ")[1]);
					formattedEnd = new DateTime(endDate, endTime);
				} else {
					Date endDate;
					if (!mapArgs.containsKey("start")) {
						endDate = new Date(natty.parseDate("today"));
					} else {
						endDate = new Date(start.split(" ")[0]);
					}
					Time endTime = new Time(natty.parseTime(endString));
					formattedEnd = new DateTime(endDate, endTime);
				}
			} else {
				end = natty.parseDate(endString);
				Date endDate = new Date(end);
				formattedEnd = new DateTime(endDate, new Time(""));
			}
		}
		if (mapArgs.containsKey("cats")) {
			String[] catArray = mapArgs.get("cats").split(" ");
			cats = new HashSet<String>(Arrays.asList(catArray));
		}
		try {
			return new AddCommand(taskName, formattedStart, formattedEnd, cats);
		} catch (IllegalValueException ive) {
			return new IncorrectCommand(ive.getMessage());
		}

	}

	

	/**
	 * Parses the arguments given by the user in the add command and returns it
	 * to prepareAdd in a HashMap with keys taskName, date, startTime, endTime,
	 * isRecurring
	 */

	private HashMap<String, String> parseAdd(String arguments) {
		HashMap<String, String> mapArgs = new HashMap<String, String>();
		String taskName = getTaskNameFromArguments(arguments);
		mapArgs.put("taskName", taskName);
		if (arguments.contains("/")) {
			String[] splitArgs = arguments.substring(taskName.length() + 1).split(" ");
			// loop through rest of arguments, add them to hashmap if valid

			argumentArrayToHashMap(mapArgs, splitArgs);
		}

		return mapArgs;
	}

	private HashMap<String, String> parseEdit(String arguments) {

		HashMap<String, String> mapArgs = new HashMap<String, String>();

		// Extract index
		String[] splitArgs1 = arguments.split(" ", 2);
		int indexStringLength = splitArgs1[0].length();
		String index = arguments.substring(0, indexStringLength);
		mapArgs.put("index", index);

		arguments = arguments.substring(indexStringLength + 1);
		if (hasTaskName(arguments)) {
			String taskName = getTaskNameFromArguments(arguments);
			mapArgs.put("taskName", taskName);
			if (arguments.contains("/")) {
				String[] splitArgs = arguments.substring(taskName.length() + 1).split(" ");
				argumentArrayToHashMap(mapArgs, splitArgs);
			}
		} else if (arguments.contains("/")) {
			String[] splitArgs = arguments.split(" ");
			argumentArrayToHashMap(mapArgs, splitArgs);
		}

		return mapArgs;
	}

	/*
	 * Loops through arguments, adds them to hashmap if valid
	 */

	private void argumentArrayToHashMap(HashMap<String, String> mapArgs, String[] splitArgs) {
		for (int i = 0; i < splitArgs.length; i++) {
			if (splitArgs[i].substring(0, 2).equals("s/")) {
				int j = i + 1;
				String arg = splitArgs[i].substring(2);
				while (j < splitArgs.length && !splitArgs[j].contains("/")) {
					arg += " " + splitArgs[j];
					j++;
				}
				mapArgs.put("start", arg);
			}

			if (splitArgs[i].substring(0, 2).equals("e/")) {
				int j = i + 1;
				String arg = splitArgs[i].substring(2);
				while (j < splitArgs.length && !splitArgs[j].contains("/")) {
					arg += " " + splitArgs[j];
					j++;
				}
				mapArgs.put("end", arg);
			}

			if (splitArgs[i].substring(0, 2).equals("c/")) {
				int j = i + 1;
				String arg = splitArgs[i].substring(2);
				while (j < splitArgs.length) {
					arg += " " + splitArgs[j].substring(2);
					j++;
				}
				i = j;
				mapArgs.put("cats", arg);

			}
		}
	}

```
###### \dailyplanner\model\ModelManager.java
``` java
	public ModelManager(DailyPlanner src, UserPrefs userPrefs) {
		super();
		assert src != null;
		assert userPrefs != null;

		logger.fine("Initializing with daily planner: " + src + " and user prefs " + userPrefs);

		dailyPlanner = new DailyPlanner(src);
		filteredTasks = new FilteredList<>(dailyPlanner.getTasks());
		pinnedTasks = new FilteredList<>(dailyPlanner.getPinnedTasks());
		history = new HistoryManager();
		lastTaskAddedIndex = new SimpleIntegerProperty(0);
		lastShowDate = new SimpleStringProperty();
	}

	public ModelManager() {
		this(new DailyPlanner(), new UserPrefs());
	}

	public ModelManager(ReadOnlyDailyPlanner initialData, UserPrefs userPrefs) {
		dailyPlanner = new DailyPlanner(initialData);
		filteredTasks = new FilteredList<>(dailyPlanner.getTasks());
		pinnedTasks = new FilteredList<>(dailyPlanner.getPinnedTasks());
		history = new HistoryManager();
		lastTaskAddedIndex = new SimpleIntegerProperty(0);
		lastShowDate = new SimpleStringProperty();
	}
```
###### \dailyplanner\model\task\Date.java
``` java
    /** Guarantees that value is in the format: DD/MM/YYYY */
    public Date(String value) {
        assert value != null;
        m_value = value;
        if (!value.equals("")) {
            m_day = Integer.parseInt(value.substring(0, 2));
            m_month = Integer.parseInt(value.substring(3, 5));
            m_year = Integer.parseInt(value.substring(6));
        } else {
            m_day = 0;
            m_month = 0;
            m_year = 3000;
        }
    }

    @Override
    public String toString() {
        return m_value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Date // instanceof handles nulls
                        && m_value.equals(((Date) other).m_value)); // state
        // check
    }

    @Override
    public int hashCode() {
        return m_value.hashCode();
    }

    @Override
    public int compareTo(Date o) {

        if (m_year != o.m_year) {
            return m_year - o.m_year;
        }
        if (m_month != o.m_month) {
            return m_month - o.m_month;
        }
        if (m_day != o.m_day) {
            return m_day - o.m_day;
        }

        return 0;
    }
}
```
###### \dailyplanner\model\task\Task.java
``` java
	private String taskName;
	private DateTime start;
	private DateTime end;
	private boolean isComplete;
	private boolean isPinned;
	private UniqueCategoryList tags;

	/**
	 * Every field must be present and not null.
	 */
	public Task(String name, DateTime start, DateTime end, boolean isComplete, boolean isPinned, UniqueCategoryList tags) {
	    assert !CollectionUtil.isAnyNull(name, start, end, isComplete, isPinned, tags);
		this.taskName = name;
		this.start = start;
		this.end = end;
		this.tags = new UniqueCategoryList(tags); // protect internal tags from
		// changes in the arg list
		this.isComplete = isComplete;
		this.isPinned = isPinned;
	}

	/**
	 * Copy constructor.
	 */
	public Task(ReadOnlyTask source) {
		this(source.getName(), source.getStart(), source.getEnd(), source.isComplete(), source.isPinned(),
				source.getCats());
	}

	@Override
	public void setName(String name) {
		this.taskName = name;
	}

	@Override
	public void setStart(DateTime startDate) {
		this.start = startDate;
	}

	@Override
	public void setEnd(DateTime endDate) {
		this.end = endDate;
	}

	@Override
	public void markAsComplete() {
		this.isComplete = true;
	}

	@Override
	public void markAsNotComplete() {
		this.isComplete = false;
	}

	public void pin() {
		this.isPinned = true;
	}

	public void unpin() {
		this.isPinned = false;
	}

	public static String calculateDueStatus(DateTime end) {
		// if there is no end date, return empty string
		if (end.getDate().equals("")) {
			return "";
		}
		DateTime nowAsDateTime = DateUtil.nowAsDateTime();
		
		// if end date is strictly before current date
		if (end.getDate().compareTo(nowAsDateTime.getDate()) < 0 ) {
			return "OVERDUE";
		}
		
		// if end date is today or later but there is no end time
		if (end.getTime().toString().equals("")) {
			return "";
		}
		
		// if end date is same as current date
		else if (end.getDate().equals(nowAsDateTime.getDate())) {
			// if end time is before or equal to current time
			if (end.getTime().compareTo(nowAsDateTime.getTime()) <= 0) {
				return "OVERDUE";
			} else {
				int endHour = DateUtil.convertTo24HrFormat(end.getTime());
				int nowHour = DateUtil.convertTo24HrFormat(nowAsDateTime.getTime());
				int overDueHours = endHour - nowHour;
				if (overDueHours <= 3) {
					return "DUE SOON";
				}
			}
		}
		return "";
	}

	@Override
	public String getName() {
		return taskName;
	}

	@Override
	public DateTime getStart() {
		return start;
	}

	@Override
	public DateTime getEnd() {
		return end;
	}

	@Override
	public String getCompletion() {
		return (isComplete) ? "COMPLETE" : "NOT COMPLETE";
	}

	@Override
	public String getDueStatus() {
		return calculateDueStatus(end);
	}

	@Override
	public boolean isComplete() {
		return isComplete;
	}

	@Override
	public void setCompletion(boolean completion) {
		isComplete = completion;
	}

	public boolean isPinned() {
		return isPinned;
	}

	@Override
	public UniqueCategoryList getCats() {
		return new UniqueCategoryList(tags);
	}

	/**
	 * Replaces this task's tags with the tags in the argument tag list.
	 */
	public void setCategories(UniqueCategoryList replacement) {
		tags.setTags(replacement);
	}

	@Override
	public boolean equals(Object other) {
		return other == this // short circuit if same object
				|| (other instanceof ReadOnlyTask // instanceof handles nulls
						&& this.isSameStateAs((ReadOnlyTask) other));
	}

	@Override
	public int hashCode() {
		return Objects.hash(taskName, start, end, isComplete, isPinned, tags);
	}

	@Override
	public String toString() {
		return getAsText();
	}

	@Override
	public int compareTo(Task o) {
		if (!start.equals(o.start)) {
			return start.compareTo(o.start);
		} else if (!end.equals(o.end)) {
			return end.compareTo(o.end);
		} else
			return taskName.compareTo(o.taskName);
	}

}
```
###### \dailyplanner\ui\PinnedTaskPanel.java
``` java
public class PinnedTaskPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(PinnedTaskPanel.class);
    private static final String FXML = "PinnedTaskPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private ListView<ReadOnlyTask> pinListView;

    public PinnedTaskPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static PinnedTaskPanel load(Stage primaryStage, AnchorPane PinnedTaskPlaceholder,
                                       ObservableList<ReadOnlyTask> pinnedTaskList) {
        PinnedTaskPanel pinnedTaskPanel =
                UiPartLoader.loadUiPart(primaryStage, PinnedTaskPlaceholder, new PinnedTaskPanel());
        pinnedTaskPanel.configure(pinnedTaskList);
        return pinnedTaskPanel;
    }

    private void configure(ObservableList<ReadOnlyTask> personList) {
        setConnections(personList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<ReadOnlyTask> personList) {
        pinListView.setItems(personList);
        pinListView.setCellFactory(listView -> new PersonListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void setEventHandlerForSelectionChangeEvent() {
        pinListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in person list panel changed to : '" + newValue + "'");
                raise(new TaskPanelSelectionChangedEvent(newValue));
            }
        });
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            pinListView.scrollTo(index);
            pinListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class PersonListViewCell extends ListCell<ReadOnlyTask> {

        public PersonListViewCell() {
        }

        @Override
        protected void updateItem(ReadOnlyTask person, boolean empty) {
            super.updateItem(person, empty);

            if (empty || person == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(TaskCard.load(person, getIndex() + 1).getLayout());
            }
        }
    }

}
```
###### \dailyplanner\ui\ResultDisplay.java
``` java
    public void configure() {
        resultDisplayArea = new TextArea();
        resultDisplayArea.setEditable(false);
        resultDisplayArea.setId(RESULT_DISPLAY_ID);
        resultDisplayArea.getStyleClass().removeAll();
        resultDisplayArea.getStyleClass().add(STATUS_BAR_STYLE_SHEET);
        resultDisplayArea.setWrapText(true);
        resultDisplayArea.setText("");
        resultDisplayArea.textProperty().bind(displayed);
        displayed.setValue(INITIAL_RESULT_MESSAGE);
        FxViewUtil.applyAnchorBoundaryParameters(resultDisplayArea, 0.0, 0.0, 0.0, 0.0);
        mainPane.getChildren().add(resultDisplayArea);
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public void postMessage(String message) {
        displayed.setValue(message);
    }

}
```
###### \dailyplanner\ui\TaskCard.java
``` java
    @FXML
    public void initialize() {
	name.setText(task.getName());
	name.setWrapText(true);
	id.setText(displayedIndex + ". ");
	startDate.setText(task.getStart().getDate().toString());
	startTime.setText(task.getStart().getTime().toString());
	endDate.setText(task.getEnd().getDate().toString());
	endTime.setText(task.getEnd().getTime().toString());
	tags.setText(task.tagsString());
	if (task.isComplete()) {
	    isComplete.setText(task.getCompletion());
	    isComplete.setVisible(true);
	} else {
	    String dueStatus = task.getDueStatus();
	    if(dueStatus.equals("")) {
	        isComplete.setVisible(false);
	    } else {
	        isComplete.setText(dueStatus);
	        if (dueStatus.equals("DUE SOON")) {
	            isComplete.setStyle(DUE_SOON_LABEL_STYLE);
	        } else if (dueStatus.equals("OVERDUE")) {
	            isComplete.setStyle(OVERDUE_LABEL_STYLE);
	        }
	        
	    }
	}

	if (task.getStart().getDate().toString().equals("")) {
	    startAtLabel.setVisible(false);
	} else {
	    startAtLabel.setText("Starts at: ");
	}

	if (task.getEnd().getDate().toString().equals("")) {
	    endAtLabel.setVisible(false);
	} else {
	    endAtLabel.setText("Ends at: ");
	}

    }
```
